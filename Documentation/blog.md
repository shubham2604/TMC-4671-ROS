# Controlling brushless motors with ROS

One of the challenges while developing any robotic hardware is to handle the communications with the motors along with sending commands to them as per the generated trajectory in real time. Since the motor accepting trajectories should respect the time limits, it becomes important that the communication between the motor driver and the controller is seamless. Furthermore, the controller should also receive the latest joint state (position, velocity, effort) information from the motor so that the trajectory execution can be verified. The final challenge that remains afterward is to actually generate the trajectory and send it to the motor driver. 

To achieve these requirements ROS framework provides us with the several tools such as ROS-control and ROS-Moveit. ROS (Robot Operating System) is a software framework that implement state-of-the-art algorithms and tools to simplify the development of robotic hardware and software with minimal efforts. 

To control any joint actuator there can be multiple methods, such as, commanding joint positions, joint velocity, or, joint efforts. It completely depend on the application that, what level of control is required. Things become easier if the joint positions are directly used to command the actuator since all the low level processing such as velocity and torque control loop are executed within the drive hardware. However, if the joint velocities or joint efforts are used to command the actuator then the position interface has to be generated by running control loops on the commanding device i.e. in our case a linux machine running an instance of ROS control.

## ROS-control
ROS-control is a  ROS package capable of interfacing with multiple hardware instances mentioned above. To do so, it provides abstraction over the implementation of control loops such that any motor or actuator can be controlled irrespective of its hardware interface. 

As per the official documentation, there can be four types of hardware interfaces that ROS-control can natively support:

 1.  Joint Command Interface
		-  Effort Joint Interface
		-  Velocity Joint Interface
		-  Position Joint Interface
 2. Joint State Interface

The Interfaces can be best understood by the following image,

![ROS hardware interface memory concepts, source : https://roscon.ros.org/2014/wp-content/uploads/2014/07/ros_control_an_overview.pdf](https://github.com/shubham2604/TMC-4671-ROS/blob/master/Images/HW_interface_Mem_loc.png)

As evident from the image, ROS control communicate with the actuators and the motors using the memory locations. For example, if the motor has to be commanded using the position interface, ROS control would simply write the position demand value at "pos_cmd_" memory location which would be then transmitted to the motor via the the communication interface of the motor. In case of TMC4671 eval kit with Landungsbrücke, these interfaces can be RS232, USB serial, or RN171XV/RN42XV wireless modules. Similarly, for velocity and effort interfaces the demand values get written to these memory locations which are pre-defined. Now, the question that remains is, how does the joint states are read from the motor. It is also anologous to the joint command interface where the joint values are read into the "pos_", "vel_" and "eff_" memory locations.

Now its just matter of updating these memory locations at certain interval to command and read the joint interfaces. This process can be easily explained using following code snippet,

    class trinamic: public hardware_interface::RobotHW
    {
	    public:
	    trinamic();
	    void read();
	    void write();
    };
Here, the constructor can be used to initialize for example, communication interfaces (Serial in case of our implementation with Landungsbrücke). Moving further, both `trinamic::read()` and `trinamic::write()` functions are called periodically in a loop so that the memory locations are updated at a fixed interval. 

